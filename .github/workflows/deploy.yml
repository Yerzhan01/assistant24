name: CI/CD Pipeline

on:
  push:
    branches: [ "main" ]
  create:
    tags:
      - 'v*'

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Set Environment Target
      id: target
      run: |
        if [[ "${{ github.ref }}" == "refs/heads/main" ]]; then
          echo "ENV_NAME=dev" >> $GITHUB_ENV
          echo "DOMAIN=dev.link-it.tech" >> $GITHUB_ENV
          echo "Deploying to DEVELOPMENT environment"
        elif [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          echo "ENV_NAME=prod" >> $GITHUB_ENV
          echo "DOMAIN=link-it.tech" >> $GITHUB_ENV
          echo "Deploying to PRODUCTION environment"
        fi

    - name: Install SSH Key
      uses: shimataro/ssh-key-action@v2
      with:
        key: ${{ secrets.SSH_PRIVATE_KEY }}
        known_hosts: ${{ secrets.KNOWN_HOSTS }}

    - name: Deploy to Server
      env:
        HOST: ${{ secrets.HOST }}
        USER: root
        PROJECT_PATH: /app/${{ env.ENV_NAME }}
      run: |
        # Create separate directories for dev and prod
        ssh $USER@$HOST "mkdir -p $PROJECT_PATH"

        # Transfer files (excluding unwanted) via rsync
        rsync -avz -e "ssh -o StrictHostKeyChecking=no" --exclude '.git' --exclude 'venv' --exclude 'node_modules' --exclude '__pycache__' ./ $USER@$HOST:$PROJECT_PATH/

        # Configure Ports
        BACKEND_PORT=8000
        FRONTEND_PORT=3000
        
        if [[ "${{ env.ENV_NAME }}" == "dev" ]]; then
          BACKEND_PORT=8001
          FRONTEND_PORT=3001
        fi

        # Run Deployment
        # Using StrictHostKeyChecking=no to avoid known_hosts issues in CI
        ssh -o StrictHostKeyChecking=no $USER@$HOST "cd $PROJECT_PATH && \
          export DOMAIN=${{ env.DOMAIN }} && \
          export BACKEND_PORT=$BACKEND_PORT && \
          export FRONTEND_PORT=$FRONTEND_PORT && \
          # Ensure .env exists or Copy default
          if [ ! -f .env ]; then cp .env.example .env 2>/dev/null || touch .env; fi && \
          # Append/Update ports in .env for docker compose to pick up if not passing via shell env (Compose v2 reads shell env)
          docker compose down && \
          docker compose up -d --build"
